import {
  __commonJS
} from "./chunk-VK5M77CT.js";

// node_modules/@iconfu/svg-inject/dist/svg-inject.js
var require_svg_inject = __commonJS({
  "node_modules/@iconfu/svg-inject/dist/svg-inject.js"(exports, module) {
    (function(window2, document2) {
      var _CREATE_ELEMENT_ = "createElement";
      var _GET_ELEMENTS_BY_TAG_NAME_ = "getElementsByTagName";
      var _LENGTH_ = "length";
      var _STYLE_ = "style";
      var _TITLE_ = "title";
      var _UNDEFINED_ = "undefined";
      var _SET_ATTRIBUTE_ = "setAttribute";
      var _GET_ATTRIBUTE_ = "getAttribute";
      var NULL = null;
      var __SVGINJECT = "__svgInject";
      var ID_SUFFIX = "--inject-";
      var ID_SUFFIX_REGEX = new RegExp(ID_SUFFIX + "\\d+", "g");
      var LOAD_FAIL = "LOAD_FAIL";
      var SVG_NOT_SUPPORTED = "SVG_NOT_SUPPORTED";
      var SVG_INVALID = "SVG_INVALID";
      var ATTRIBUTE_EXCLUSION_NAMES = ["src", "alt", "onload", "onerror"];
      var A_ELEMENT = document2[_CREATE_ELEMENT_]("a");
      var IS_SVG_SUPPORTED = typeof SVGRect != _UNDEFINED_;
      var DEFAULT_OPTIONS = {
        useCache: true,
        copyAttributes: true,
        makeIdsUnique: true
      };
      var IRI_TAG_PROPERTIES_MAP = {
        clipPath: ["clip-path"],
        "color-profile": NULL,
        cursor: NULL,
        filter: NULL,
        linearGradient: ["fill", "stroke"],
        marker: ["marker", "marker-end", "marker-mid", "marker-start"],
        mask: NULL,
        pattern: ["fill", "stroke"],
        radialGradient: ["fill", "stroke"]
      };
      var INJECTED = 1;
      var FAIL = 2;
      var uniqueIdCounter = 1;
      var xmlSerializer;
      var domParser;
      function svgStringToSvgDoc(svgStr) {
        domParser = domParser || new DOMParser();
        return domParser.parseFromString(svgStr, "text/xml");
      }
      function svgElemToSvgString(svgElement) {
        xmlSerializer = xmlSerializer || new XMLSerializer();
        return xmlSerializer.serializeToString(svgElement);
      }
      function getAbsoluteUrl(url) {
        A_ELEMENT.href = url;
        return A_ELEMENT.href;
      }
      function loadSvg(url, callback, errorCallback) {
        if (url) {
          var req = new XMLHttpRequest();
          req.onreadystatechange = function() {
            if (req.readyState == 4) {
              var status = req.status;
              if (status == 200) {
                callback(req.responseXML, req.responseText.trim());
              } else if (status >= 400) {
                errorCallback();
              } else if (status == 0) {
                errorCallback();
              }
            }
          };
          req.open("GET", url, true);
          req.send();
        }
      }
      function copyAttributes(imgElem, svgElem) {
        var attribute;
        var attributeName;
        var attributeValue;
        var attributes = imgElem.attributes;
        for (var i = 0; i < attributes[_LENGTH_]; i++) {
          attribute = attributes[i];
          attributeName = attribute.name;
          if (ATTRIBUTE_EXCLUSION_NAMES.indexOf(attributeName) == -1) {
            attributeValue = attribute.value;
            if (attributeName == _TITLE_) {
              var titleElem;
              var firstElementChild = svgElem.firstElementChild;
              if (firstElementChild && firstElementChild.localName.toLowerCase() == _TITLE_) {
                titleElem = firstElementChild;
              } else {
                titleElem = document2[_CREATE_ELEMENT_ + "NS"]("http://www.w3.org/2000/svg", _TITLE_);
                svgElem.insertBefore(titleElem, firstElementChild);
              }
              titleElem.textContent = attributeValue;
            } else {
              svgElem[_SET_ATTRIBUTE_](attributeName, attributeValue);
            }
          }
        }
      }
      function makeIdsUnique(svgElem, onlyReferenced) {
        var idSuffix = ID_SUFFIX + uniqueIdCounter++;
        var funcIriRegex = /url\("?#([a-zA-Z][\w:.-]*)"?\)/g;
        var idElements = svgElem.querySelectorAll("[id]");
        var idElem;
        var referencedIds = onlyReferenced ? [] : NULL;
        var tagName;
        var iriTagNames = {};
        var iriProperties = [];
        var changed = false;
        var i, j;
        if (idElements[_LENGTH_]) {
          for (i = 0; i < idElements[_LENGTH_]; i++) {
            tagName = idElements[i].localName;
            if (tagName in IRI_TAG_PROPERTIES_MAP) {
              iriTagNames[tagName] = 1;
            }
          }
          for (tagName in iriTagNames) {
            (IRI_TAG_PROPERTIES_MAP[tagName] || [tagName]).forEach(function(mappedProperty) {
              if (iriProperties.indexOf(mappedProperty) < 0) {
                iriProperties.push(mappedProperty);
              }
            });
          }
          if (iriProperties[_LENGTH_]) {
            iriProperties.push(_STYLE_);
          }
          var descElements = svgElem[_GET_ELEMENTS_BY_TAG_NAME_]("*");
          var element = svgElem;
          var propertyName;
          var value;
          var newValue;
          for (i = -1; element != NULL; ) {
            if (element.localName == _STYLE_) {
              value = element.textContent;
              newValue = value && value.replace(funcIriRegex, function(match, id) {
                if (referencedIds) {
                  referencedIds[id] = 1;
                }
                return "url(#" + id + idSuffix + ")";
              });
              if (newValue !== value) {
                element.textContent = newValue;
              }
            } else if (element.hasAttributes()) {
              for (j = 0; j < iriProperties[_LENGTH_]; j++) {
                propertyName = iriProperties[j];
                value = element[_GET_ATTRIBUTE_](propertyName);
                newValue = value && value.replace(funcIriRegex, function(match, id) {
                  if (referencedIds) {
                    referencedIds[id] = 1;
                  }
                  return "url(#" + id + idSuffix + ")";
                });
                if (newValue !== value) {
                  element[_SET_ATTRIBUTE_](propertyName, newValue);
                }
              }
              ["xlink:href", "href"].forEach(function(refAttrName) {
                var iri = element[_GET_ATTRIBUTE_](refAttrName);
                if (/^\s*#/.test(iri)) {
                  iri = iri.trim();
                  element[_SET_ATTRIBUTE_](refAttrName, iri + idSuffix);
                  if (referencedIds) {
                    referencedIds[iri.substring(1)] = 1;
                  }
                }
              });
            }
            element = descElements[++i];
          }
          for (i = 0; i < idElements[_LENGTH_]; i++) {
            idElem = idElements[i];
            if (!referencedIds || referencedIds[idElem.id]) {
              idElem.id += idSuffix;
              changed = true;
            }
          }
        }
        return changed;
      }
      function makeIdsUniqueCached(svgString) {
        return svgString.replace(ID_SUFFIX_REGEX, ID_SUFFIX + uniqueIdCounter++);
      }
      function inject(imgElem, svgElem, absUrl, options) {
        if (svgElem) {
          svgElem[_SET_ATTRIBUTE_]("data-inject-url", absUrl);
          var parentNode = imgElem.parentNode;
          if (parentNode) {
            if (options.copyAttributes) {
              copyAttributes(imgElem, svgElem);
            }
            var beforeInject = options.beforeInject;
            var injectElem = beforeInject && beforeInject(imgElem, svgElem) || svgElem;
            parentNode.replaceChild(injectElem, imgElem);
            imgElem[__SVGINJECT] = INJECTED;
            removeOnLoadAttribute(imgElem);
            var afterInject = options.afterInject;
            if (afterInject) {
              afterInject(imgElem, injectElem);
            }
          }
        } else {
          svgInvalid(imgElem, options);
        }
      }
      function mergeOptions() {
        var mergedOptions = {};
        var args = arguments;
        for (var i = 0; i < args[_LENGTH_]; i++) {
          var argument = args[i];
          for (var key in argument) {
            if (argument.hasOwnProperty(key)) {
              mergedOptions[key] = argument[key];
            }
          }
        }
        return mergedOptions;
      }
      function addStyleToHead(css) {
        var head = document2[_GET_ELEMENTS_BY_TAG_NAME_]("head")[0];
        if (head) {
          var style = document2[_CREATE_ELEMENT_](_STYLE_);
          style.type = "text/css";
          style.appendChild(document2.createTextNode(css));
          head.appendChild(style);
        }
      }
      function buildSvgElement(svgStr, verify) {
        if (verify) {
          var svgDoc;
          try {
            svgDoc = svgStringToSvgDoc(svgStr);
          } catch (e) {
            return NULL;
          }
          if (svgDoc[_GET_ELEMENTS_BY_TAG_NAME_]("parsererror")[_LENGTH_]) {
            return NULL;
          }
          return svgDoc.documentElement;
        } else {
          var div = document2.createElement("div");
          div.innerHTML = svgStr;
          return div.firstElementChild;
        }
      }
      function removeOnLoadAttribute(imgElem) {
        imgElem.removeAttribute("onload");
      }
      function errorMessage(msg) {
        console.error("SVGInject: " + msg);
      }
      function fail(imgElem, status, options) {
        imgElem[__SVGINJECT] = FAIL;
        if (options.onFail) {
          options.onFail(imgElem, status);
        } else {
          errorMessage(status);
        }
      }
      function svgInvalid(imgElem, options) {
        removeOnLoadAttribute(imgElem);
        fail(imgElem, SVG_INVALID, options);
      }
      function svgNotSupported(imgElem, options) {
        removeOnLoadAttribute(imgElem);
        fail(imgElem, SVG_NOT_SUPPORTED, options);
      }
      function loadFail(imgElem, options) {
        fail(imgElem, LOAD_FAIL, options);
      }
      function removeEventListeners(imgElem) {
        imgElem.onload = NULL;
        imgElem.onerror = NULL;
      }
      function imgNotSet(msg) {
        errorMessage("no img element");
      }
      function createSVGInject(globalName, options) {
        var defaultOptions = mergeOptions(DEFAULT_OPTIONS, options);
        var svgLoadCache = {};
        if (IS_SVG_SUPPORTED) {
          addStyleToHead('img[onload^="' + globalName + '("]{visibility:hidden;}');
        }
        function SVGInject(img, options2) {
          options2 = mergeOptions(defaultOptions, options2);
          var run = function(resolve) {
            var allFinish = function() {
              var onAllFinish = options2.onAllFinish;
              if (onAllFinish) {
                onAllFinish();
              }
              resolve && resolve();
            };
            if (img && typeof img[_LENGTH_] != _UNDEFINED_) {
              var injectIndex = 0;
              var injectCount = img[_LENGTH_];
              if (injectCount == 0) {
                allFinish();
              } else {
                var finish = function() {
                  if (++injectIndex == injectCount) {
                    allFinish();
                  }
                };
                for (var i = 0; i < injectCount; i++) {
                  SVGInjectElement(img[i], options2, finish);
                }
              }
            } else {
              SVGInjectElement(img, options2, allFinish);
            }
          };
          return typeof Promise == _UNDEFINED_ ? run() : new Promise(run);
        }
        function SVGInjectElement(imgElem, options2, callback) {
          if (imgElem) {
            var svgInjectAttributeValue = imgElem[__SVGINJECT];
            if (!svgInjectAttributeValue) {
              removeEventListeners(imgElem);
              if (!IS_SVG_SUPPORTED) {
                svgNotSupported(imgElem, options2);
                callback();
                return;
              }
              var beforeLoad = options2.beforeLoad;
              var src = beforeLoad && beforeLoad(imgElem) || imgElem[_GET_ATTRIBUTE_]("src");
              if (!src) {
                if (src === "") {
                  loadFail(imgElem, options2);
                }
                callback();
                return;
              }
              var onFinishCallbacks = [];
              imgElem[__SVGINJECT] = onFinishCallbacks;
              var onFinish = function() {
                callback();
                onFinishCallbacks.forEach(function(onFinishCallback) {
                  onFinishCallback();
                });
              };
              var absUrl = getAbsoluteUrl(src);
              var useCacheOption = options2.useCache;
              var makeIdsUniqueOption = options2.makeIdsUnique;
              var setSvgLoadCacheValue = function(val) {
                if (useCacheOption) {
                  svgLoadCache[absUrl].forEach(function(svgLoad2) {
                    svgLoad2(val);
                  });
                  svgLoadCache[absUrl] = val;
                }
              };
              if (useCacheOption) {
                var svgLoad = svgLoadCache[absUrl];
                var handleLoadValue = function(loadValue) {
                  if (loadValue === LOAD_FAIL) {
                    loadFail(imgElem, options2);
                  } else if (loadValue === SVG_INVALID) {
                    svgInvalid(imgElem, options2);
                  } else {
                    var hasUniqueIds = loadValue[0];
                    var svgString = loadValue[1];
                    var uniqueIdsSvgString = loadValue[2];
                    var svgElem;
                    if (makeIdsUniqueOption) {
                      if (hasUniqueIds === NULL) {
                        svgElem = buildSvgElement(svgString, false);
                        hasUniqueIds = makeIdsUnique(svgElem, false);
                        loadValue[0] = hasUniqueIds;
                        loadValue[2] = hasUniqueIds && svgElemToSvgString(svgElem);
                      } else if (hasUniqueIds) {
                        svgString = makeIdsUniqueCached(uniqueIdsSvgString);
                      }
                    }
                    svgElem = svgElem || buildSvgElement(svgString, false);
                    inject(imgElem, svgElem, absUrl, options2);
                  }
                  onFinish();
                };
                if (typeof svgLoad != _UNDEFINED_) {
                  if (svgLoad.isCallbackQueue) {
                    svgLoad.push(handleLoadValue);
                  } else {
                    handleLoadValue(svgLoad);
                  }
                  return;
                } else {
                  var svgLoad = [];
                  svgLoad.isCallbackQueue = true;
                  svgLoadCache[absUrl] = svgLoad;
                }
              }
              loadSvg(absUrl, function(svgXml, svgString) {
                var svgElem = svgXml instanceof Document ? svgXml.documentElement : buildSvgElement(svgString, true);
                var afterLoad = options2.afterLoad;
                if (afterLoad) {
                  var svgElemOrSvgString = afterLoad(svgElem, svgString) || svgElem;
                  if (svgElemOrSvgString) {
                    var isString = typeof svgElemOrSvgString == "string";
                    svgString = isString ? svgElemOrSvgString : svgElemToSvgString(svgElem);
                    svgElem = isString ? buildSvgElement(svgElemOrSvgString, true) : svgElemOrSvgString;
                  }
                }
                if (svgElem instanceof SVGElement) {
                  var hasUniqueIds = NULL;
                  if (makeIdsUniqueOption) {
                    hasUniqueIds = makeIdsUnique(svgElem, false);
                  }
                  if (useCacheOption) {
                    var uniqueIdsSvgString = hasUniqueIds && svgElemToSvgString(svgElem);
                    setSvgLoadCacheValue([hasUniqueIds, svgString, uniqueIdsSvgString]);
                  }
                  inject(imgElem, svgElem, absUrl, options2);
                } else {
                  svgInvalid(imgElem, options2);
                  setSvgLoadCacheValue(SVG_INVALID);
                }
                onFinish();
              }, function() {
                loadFail(imgElem, options2);
                setSvgLoadCacheValue(LOAD_FAIL);
                onFinish();
              });
            } else {
              if (Array.isArray(svgInjectAttributeValue)) {
                svgInjectAttributeValue.push(callback);
              } else {
                callback();
              }
            }
          } else {
            imgNotSet();
          }
        }
        SVGInject.setOptions = function(options2) {
          defaultOptions = mergeOptions(defaultOptions, options2);
        };
        SVGInject.create = createSVGInject;
        SVGInject.err = function(img, fallbackSrc) {
          if (img) {
            if (img[__SVGINJECT] != FAIL) {
              removeEventListeners(img);
              if (!IS_SVG_SUPPORTED) {
                svgNotSupported(img, defaultOptions);
              } else {
                removeOnLoadAttribute(img);
                loadFail(img, defaultOptions);
              }
              if (fallbackSrc) {
                removeOnLoadAttribute(img);
                img.src = fallbackSrc;
              }
            }
          } else {
            imgNotSet();
          }
        };
        window2[globalName] = SVGInject;
        return SVGInject;
      }
      var SVGInjectInstance = createSVGInject("SVGInject");
      if (typeof module == "object" && typeof module.exports == "object") {
        module.exports = SVGInjectInstance;
      }
    })(window, document);
  }
});

// dep:@iconfu_svg-inject
var iconfu_svg_inject_default = require_svg_inject();
export {
  iconfu_svg_inject_default as default
};
/**
 * SVGInject - Version 1.2.3
 * A tiny, intuitive, robust, caching solution for injecting SVG files inline into the DOM.
 *
 * https://github.com/iconfu/svg-inject
 *
 * Copyright (c) 2018 INCORS, the creators of iconfu.com
 * @license MIT License - https://github.com/iconfu/svg-inject/blob/master/LICENSE
 */
//# sourceMappingURL=@iconfu_svg-inject.js.map
